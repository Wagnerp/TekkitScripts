-- Description: Nuclear Power Plant Controller
-- Authors:     andersevenrud, larsmaehlum
-- URL:         https://github.com/andersevenrud/TekkitScripts

-- Configuration
pulseTime         = 0.4
sleepTime         = 0.1
alarmTime         = 0.5
coolantTime       = 5
fuelTime          = 10
checkTicks        = 10
rebootTries       = 3
reactorsEnabled   = {1, 2}
reactorCount      = 2
monitorClientIds  = {45}

-- Thresholds
maxCoolant  = 10
maxFuel     = 44
maxSlots    = 54
maxHeat     = 2000

-- Peripherals
wlanOn        = true
wlanSide      = "top"
bundleSide    = "back"
buttonSide    = "front"
alarmSide     = "right"
sensorName    = "Sensor"
wireTriggers  = {}

table.insert(wireTriggers, {
  power         = colors.red,
  coolant       = colors.lime,
  fuel          = colors.yellow,
  alarm         = colors.orange
})
table.insert(wireTriggers, {
  power         = colors.blue,
  coolant       = colors.white,
  fuel          = colors.black,
  alarm         = colors.orange
})

-- Internal variables
debugOn      = false                      -- Debug mode, cmd argument
dryRun       = false                      -- Don't send any signals, cmd argument
_argv        = { ... }                    -- Cmd arguments
_ctrl        = sensors.getController()    -- Sensor controller
_tick        = 0                          -- For checking contents
_tick2       = 0                          -- For button delay
_inQueue     = {}                         -- Entities in queue
_lastStatus  = {}
_running     = true                       -- Loop running ?
_started     = false                      -- Button clicked once ?

for i = 1, reactorCount do
  table.insert(_lastStatus, {info = {}, contents = {}, state = false, overHeated = false, rebootTries = 0})
  table.insert(_inQueue, {coolantTime = 0, fuelTime = 0})
end

-- 
-- Helper functions
-- 

function inArray(k, o)
  local found = false
  for re = 1, #o do
    if o[re] == k then
      found = true
      break
    end
  end
  return (found)
end

function serialize(o)
  local s = ""

  if type(o) == "number" then
    s = s..o
  elseif type(o) == "string" then
    s = s..string.format("%q", o)
  elseif type(o) == "boolean" then
    s = s..tostring(o)
  elseif type(o) == "table" then
    local tmp = {}
    for k,v in pairs(o) do
      table.insert(tmp, "  [" .. serialize(k) .."] = " .. serialize(v))
    end
    s = s.."{\n"..table.concat(tmp, ",\n").."}\n"
  else
    error("cannot serialize a " .. type(o))
  end

  return (s)
end

function dprint(msg)
  print(string.format("%d %s", os.time() * 1000, msg))
end

function cprint(msg, y)
  term.setCursorPos(1, y)
  term.clearLine()
  print(msg)
end

function prints()
  term.clear()
  term.setCursorPos(1, 1)
  local msg = string.format("!  C:%02d F:%02d S:%02d | H:%04d O:---- | DRY:%s", maxCoolant, maxFuel, maxSlots, maxHeat, tostring(dryRun))
  print(msg)
end

function parseCmd()
  local _l = nil
  for i = 1, #_argv do
    local _v = _argv[i]

    if (i % 2) == 1 then
      _l = _v
    else
      if _l == "-dryRun" then
        if _v == "true" then
          dryRun = true
        else
          dryRun = false
        end
      elseif _l == "-debugOn" then
        if _v == "true" then
          debugOn = true
        else
          debugOn = false
        end
      end
    end
  end
end

function clearScreen()
  term.clear()
  term.setCursorPos(1, 1)
end

-- 
-- Networking
-- 

function sendMessage(client, message)
  if wlanOn then
    if type(client) == "table" then
      for i = 1, #client do
        rednet.send(tonumber(client[i]), message)
      end
    else
      rednet.send(tonumber(client), message)
    end
  end
end

function startNetwork()
  if wlanOn then
    rednet.open(wlanSide)
  end
end

function stopNetwork()
  if wlanOn then
    rednet.close(wlanSide)
  end
end

-- 
-- Reactor functions
-- 

function getReactorInfo(id)
  local p = "Reactor"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  local d = nil

  if t and t[id] then
    d = sensors.getSensorReadingAsDict(_ctrl, sensorName, t[id], p)
  end

  if type(d) ~= "table" or (type(d.output) == "nil") then
    d = {
      heat              = 0,
      size              = 0,
      addedToEnergyNet  = false,
      lastOutput        = 0,
      output            = 0
    }
  end

  return (d)
end

function getReactorContents(id)
  local contents = {
    coolant  = 0,
    fuel     = 0,
    depleted = 0
  }

  local p = "ReactorContent"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  if type(t) == "table" and t[id] then
    local d = sensors.getSensorReadingAsTable(_ctrl, sensorName, t[id], p)

    for i = 1, #d do
      local ii = d[i]
      if string.match(ii, "tile.ice") then
        contents.coolant = contents.coolant + 1
      elseif string.match(ii, "UranEmpty") then
        contents.depleted = contents.depleted + 1
      elseif string.match(ii, "Uran") then
        contents.fuel = contents.fuel + 1
      end
    end
  end

  return (contents)
end

function stopReactors()
  for i = 1, #reactorsEnabled do
    stopReactor(reactorsEnabled[i])
  end
end

function startReactors()
  for i = 1, #reactorsEnabled do
    startReactor(reactorsEnabled[i])
  end
end

function startReactor(id)
  if not checkReactorState(id) then
    dprint("#"..id.." >>> STARTING REACTOR <<<")
    sendPulse(wireTriggers[id].power)
  end
end

function stopReactor(id, heat)
  if checkReactorState(id) then
    if _started then
      if heat then
        dprint("#"..id.." >>> STOPPING REACTOR -- WAY TO HOT! <<<")
      else
        dprint("#"..id.." >>> STOPPING REACTOR <<<")
      end
    end

    sendPulse(wireTriggers[id].power)
  end
end

function checkReactorState(id, info)
  if not info then
    info = getReactorInfo(id)
  end

  if info then
    if info.output > 0 then
      return (true)
    end
  end

  return (false)
end

function _pollReactorCoolant(d, i, id)
  local count = 0
  if d.coolant < maxCoolant then
    count = maxCoolant - d.coolant
  end

  return (count)
end

function _pollReactorFuel(d, i, id)
  local count = 0
  if d.fuel < maxFuel then
    count = maxFuel - d.fuel
  end

  return (count)
end

function pollReactor(id, runcheck)
  local i = getReactorInfo(id)
  local d = getReactorContents(id)
  local e = checkReactorState(id, i)
  local c = nil
  local r = true

  _lastStatus[id].info      = i
  _lastStatus[id].contents  = d
  _lastStatus[id].state     = e

  -- Skip if not enabled
  if not inArray(id, reactorsEnabled) then
    return (r)
  end

  if debugOn then
    dprint("Polling #"..id)
  end

  if not dryRun and runcheck then
    local total = (d.coolant + d.fuel + d.depleted)
    local full = total >= maxSlots
    if e then
      -- Check contents
      if _tick >= checkTicks then
        if not full then
          c = _pollReactorCoolant(d, i, id)
          if c > 0 then
            pushCoolant(id, c)
            r = false
          end

          c = _pollReactorFuel(d, i, id)
          if c > 0 then
            pushFuel(id, c)
            r = false
          end
        end
      end

      -- Check environment
      if i.heat > maxHeat then
        soundAlarm()
        stopReactor(id, true)
        r = false
        _lastStatus[id].overHeated = true
      else
        stopAlarm()
        _lastStatus[id].overHeated = false
      end

      _lastStatus[id].rebootTries = 0
    else
      -- Check environment
      if _lastStatus[id].overHeated == true and (_lastStatus[id].rebootTries <= rebootTries) then
        startReactor(id)
        r = false

        if checkReactorState(id) then
          _lastStatus[id].overHeated = false
          stopAlarm()
        else
          _lastStatus[id].rebootTries = _lastStatus[id].rebootTries + 1
        end
      end

    end
  end

  return (r)
end

-- 
-- External Systems functions
-- 

function checkWire(color)
  return 
end

function sendPulse(color, stimeout, etimeout)
  if not stimeout then stimeout = pulseTime end
  if not etimeout then etimeout = pulseTime end

  if not dryRun then
    redstone.setBundledOutput(bundleSide, 0)
    os.sleep(stimeout)
    redstone.setBundledOutput(bundleSide, color)
    os.sleep(etimeout)
  end
end

function pushCoolant(id, count)
  if not count then count = 1 end

  if  not (_inQueue[id].coolantTime > os.clock()) then
    for i = 1, count do
      dprint("#"..id.." >>> PUSHING COOLANT "..i.."/"..count.." <<<")
      sendPulse(wireTriggers[id].coolant)
    end
    _inQueue[id].coolantTime = os.clock() + coolantTime

    return (true)
  end

  return (false)
end

function pushFuel(id, count)
  if not count then count = 1 end

  if  not (_inQueue[id].fuelTime > os.clock()) then
    for i = 1, count do
      dprint("#"..id.." >>> PUSHING FUEL "..i.."/"..count.." <<<")
      sendPulse(wireTriggers[id].fuel)
    end
    _inQueue[id].fuelTime = os.clock() + fuelTime

    return (true)
  end

  return (false)
end

function soundAlarm(timeout)
  rs.setOutput(alarmSide, true)
  os.sleep(timeout or alarmTime)
  rs.setOutput(alarmSide, false)
end

function stopAlarm()
  rs.setOutput(alarmSide, false)
end

-- 
-- Main program
-- 

local sx, sy = term.getSize()
local starty = (reactorCount + 3)
local pause  = false
local inited = false
local lxpos  = 1
local lypos  = starty

-- 1: Bootup
startNetwork()
clearScreen()
parseCmd()
stopReactors()
stopAlarm()

-- 2: Main loop
while _running do

  -- 2.1: Handle last status
  if inited then
    sendMessage(monitorClientIds, serialize(_lastStatus))

    for c = 1, reactorCount do
      local d = _lastStatus[c].contents
      local i = _lastStatus[c].info
      local e = _lastStatus[c].state
      local msg = string.format("#%d C:%02d F:%02d D:%02d | H:%04d O:%04d | ON:%s", c, d.coolant, d.fuel, d.depleted, i.heat, i.output, tostring(e))
      cprint(msg, 1 + c)
    end
  else
    prints()
  end

  cprint("-------------------------------------------------", (reactorCount + 2))
  term.setCursorPos(lxpos, lypos)

  -- 2.2: Perform system operations
  for i = 1, reactorCount do
    pause = pollReactor(i, _started) or pause
  end
  if pause then
    os.sleep(sleepTime)
  end

  -- 2.3: Check input button(s)
  if _tick2 > 0 then
    _tick2 = _tick2 - 1
  else
    if rs.getInput(buttonSide) then
      _tick2 = 11

      if _started then
        _running = false
        dprint(">>> SAFE SHUTDOWN :-) <<<")
        break
      else
        soundAlarm(0.5)
        _started = true
        startReactors()
      end
    end
  end

  -- 2.4: Check display and prepare for next tick
  lxpos, lypos = term.getCursorPos()
  if (lypos > (sy - 1)) then
    lypos = starty
    prints()
  end

  _tick = _tick + 1
  if _tick > checkTicks then
    _tick = 0
  end

  pause = false
  inited = true
end

-- 3: Shutdown
stopReactors()
stopNetwork()
stopAlarm()
