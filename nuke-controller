-- Description: Nuclear Power Plant Controller
-- Authors:     andersevenrud, larsmaehlum
-- URL:         https://github.com/andersevenrud/TekkitScripts

-- Configuration
pulseTime         = 0.4
sleepTime         = 0.1
coolantTime       = 5
fuelTime          = 10
checkTicks        = 10
reactorsEnabled   = {1, 2}
reactorCount      = 2
monitorClientIds  = {45}


-- Thresholds
maxCoolant  = 10
maxFuel     = 44
maxSlots    = 54
maxHeat     = 2000

-- Peripherals
wlanOn        = true
wlanSide      = "top"
bundleSide    = "back"
buttonSide    = "front"
sensorName    = "Sensor"
monitorMaxY   = 17
monitorStartY = 5
wireTriggers  = {}

table.insert(wireTriggers, {
  power         = colors.red,
  coolant       = colors.lime,
  fuel          = colors.yellow,
  alarm         = colors.orange
})
table.insert(wireTriggers, {
  power         = colors.blue,
  coolant       = colors.white,
  fuel          = colors.black,
  alarm         = colors.orange
})

-- Internal variables
debugOn      = false                      -- Debug mode, cmd argument
dryRun       = false                      -- Don't send any signals, cmd argument
_argv        = { ... }                    -- Cmd arguments
_ctrl        = sensors.getController()    -- Sensor controller
_tick        = 0                          -- For checking contents
_tick2       = 0                          -- For button delay
_statusMsg   = {}                         -- Reactor status message(s), see main
_inQueue     = {}                         -- Entities in queue, see main
_overHeated  = {}
_running     = true                       -- Loop running ?
_started     = false                      -- Button clicked once ?
_alarm       = false

for i = 1, reactorCount do
  table.insert(_overHeated, false)
  table.insert(_statusMsg, "")
  table.insert(_inQueue, {
    coolant     = 0,
    fuel        = 0,
    coolantTime = 0,
    fuelTime    = 0
  })
end

-- 
-- Helper functions
-- 

function dprint(msg)
  print(os.time() * 1000, " ", msg)
end

function cprint(msg, y)
  term.setCursorPos(1, y)
  term.clearLine()
  print(msg)
end

function prints()
  term.clear()
  term.setCursorPos(1, 1)
  print("!  C:", tostring(maxCoolant), " F:", tostring(maxFuel), " H:", tostring(maxHeat), " | DRY:", tostring(dryRun))
end

function parseCmd()
  local _l = nil
  for i = 1, #_argv do
    local _v = _argv[i]

    if (i % 2) == 1 then
      _l = _v
    else
      if _l == "-dryRun" then
        if _v == "true" then
          dryRun = true
        else
          dryRun = false
        end
      elseif _l == "-debugOn" then
        if _v == "true" then
          debugOn = true
        else
          debugOn = false
        end
      end
    end
  end
end

function clearScreen()
  term.clear()
  term.setCursorPos(1, 1)
end

function startNetwork()
  if wlanOn then
    rednet.open(wlanSide)
  end
end

function stopNetwork()
  if wlanOn then
    rednet.close(wlanSide)
  end
end

-- 
-- Networking
-- 

function sendMessage(client, message)
  if wlanOn then
    if type(client) == "table" then
      for i = 1, #client do
        rednet.send(tonumber(client[i]), message)
      end
    else
      rednet.send(tonumber(client), message)
    end
  end
end

-- 
-- Reactor functions
-- 

function getReactorInfo(id)
  local p = "Reactor"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  local d = sensors.getSensorReadingAsDict(_ctrl, sensorName, t[id], p)

  if not d then
    return {
      heat = 0,
      size = 0,
      addedToEnergyNet = false,
      lastOutput = 0,
      output = 0
    }
  end

  return (d)
end

function getReactorContents(id)
  local p = "ReactorContent"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  local d = sensors.getSensorReadingAsTable(_ctrl, sensorName, t[id], p)

  local contents = {
    coolant  = 0,
    fuel     = 0,
    depleted = 0
  }

  for i = 1, #d do
    local ii = d[i]
    if string.match(ii, "tile.ice") then
      contents.coolant = contents.coolant + 1
    elseif string.match(ii, "UranEmpty") then
      contents.depleted = contents.depleted + 1
    elseif string.match(ii, "Uran") then
      contents.fuel = contents.fuel + 1
    end
  end

  return (contents)
end

function stopReactors()
  for i = 1, #reactorsEnabled do
    stopReactor(reactorsEnabled[i])
  end
end

function startReactors()
  for i = 1, #reactorsEnabled do
    startReactor(reactorsEnabled[i])
  end
end

function startReactor(id)
  if not checkReactorState(id) then
    dprint("#"..id.." >>> STARTING REACTOR <<<")
    sendPulse(wireTriggers[id].power)
  end
end

function stopReactor(id, heat)
  if checkReactorState(id) then
    if _started then
      if heat then
        dprint("#"..id.." >>> STOPPING REACTOR -- WAY TO HOT! <<<")
      else
        dprint("#"..id.." >>> STOPPING REACTOR <<<")
      end
    end

    sendPulse(wireTriggers[id].power)
  end
end

function checkReactorState(id, info)
  if not info then
    info = getReactorInfo(id)
  end

  if info then
    if info.output > 0 then
      return (true)
    end
  end

  return (false)
end

-- 
-- External Systems functions
-- 

function sendPulse(color)
  if not dryRun then
    redstone.setBundledOutput(bundleSide, 0)
    os.sleep(pulseTime)
    redstone.setBundledOutput(bundleSide, color)
    os.sleep(pulseTime)
  end
end

function pushCoolant(id, count)
  if not count then count = 1 end

  if  not (_inQueue[id].coolantTime > os.clock()) then
    for i = 1, count do
      dprint("#"..id.." >>> PUSHING COOLANT "..i.."/"..count.." <<<")
      sendPulse(wireTriggers[id].coolant)
    end
    _inQueue[id].coolantTime = os.clock() + coolantTime

    return (true)
  end

  return (false)
end

function pushFuel(id, count)
  if not count then count = 1 end

  if  not (_inQueue[id].fuelTime > os.clock()) then
    for i = 1, count do
      dprint("#"..id.." >>> PUSHING FUEL "..i.."/"..count.." <<<")
      sendPulse(wireTriggers[id].fuel)
    end
    _inQueue[id].fuelTime = os.clock() + fuelTime

    return (true)
  end

  return (false)
end

function pullDepleted()
end

function _pollReactorCoolant(d, i, id)
  local count = 0
  local wants = 0

  if d.coolant < maxCoolant then
    count = maxCoolant - d.coolant
  end

  return (count)
end

function _pollReactorFuel(d, i, id)
  local count = 0
  local wants = 0

  if d.fuel < maxFuel then
    count = maxFuel - d.fuel
  end

  return (count)
end

function pollReactor(id, runcheck)
  local i = getReactorInfo(id)
  local d = getReactorContents(id)
  local e = checkReactorState(id, i)
  local c = nil
  local r = true

  _statusMsg[id] = "#"..tostring(id).." C:"..tostring(d.coolant).."+"..tostring(_inQueue[id].coolant).." F:"..tostring(d.fuel).."+"..tostring(_inQueue[id].fuel).." D:"..tostring(d.depleted).." | H:"..tostring(i.heat).. " O:"..tostring(i.output).." | ON: "..tostring(e)

  -- Skip if not enabled
  local found = false
  for re = 1, #reactorsEnabled do
    if reactorsEnabled[re] == id then
      found = true
      break
    end
  end

  if not found then
    return (r)
  end

  if not dryRun and runcheck then
    local total = (d.coolant + d.fuel + d.depleted)
    local full = total >= maxSlots
    if e then
      -- Check contents
      if _tick >= checkTicks then
        if not full then
          c = _pollReactorCoolant(d, i, id)
          if c > 0 then
            pushCoolant(id, c)
            r = false
          end

          c = _pollReactorFuel(d, i, id)
          if c > 0 then
            pushFuel(id, c)
            r = false
          end
        end
      end

      -- Check environment
      if i.heat > maxHeat then
        soundAlarm(id)
        stopReactor(id, true)
        r = false
        _overHeated[id] = true
      else
        _overHeated[id] = false
      end
    else
      -- Check environment
      if _overHeated[id] == true then
        if i.heat < maxHeat then
          for re = 1, #reactorsEnabled do
            if reactorsEnabled[re] == id then
              startReactor(id)
              r = false

              if checkReactorState(id) then
                _overHeated[id] = false
              end
              break
            end
          end
        end
      end

    end
  end

  return (r)
end

function soundAlarm(id)
  --sendPulse(wireTriggers[id].alarm)
end

-- 
-- Main program
-- 

local pause = false
local lxpos = 1
local lypos = monitorStartY

startNetwork()
clearScreen()
parseCmd()
stopReactors()
prints()

while _running do
  sendMessage(monitorClientIds, join(_statusMsg, ";"))

  -- Show core status(es)
  cprint(_statusMsg[1], 2)
  cprint(_statusMsg[2], 3)
  cprint("-------------------------------------------------", 4)
  term.setCursorPos(lxpos, lypos)

  -- Perform system operations
  for i = 1, reactorCount do
    pause = pollReactor(i, _started) or pause
  end
  if pause then
    os.sleep(sleepTime)
  end

  -- Check input button(s)
  if _tick2 > 0 then
    _tick2 = _tick2 - 1
  else
    if rs.getInput(buttonSide) then
      _tick2 = 11

      if _started then
        _running = false
        dprint(">>> SAFE SHUTDOWN :-) <<<")
        break
      else
        _started = true
        startReactors()
      end
    end
  end

  -- Make sure display is correct (do not move, always after last input)
  lxpos, lypos = term.getCursorPos()
  if (lypos > monitorMaxY) then
    lypos = monitorStartY
    prints()
  end

  -- Prepare for next tick
  _tick = _tick + 1
  if _tick > checkTicks then
    _tick = 0
  end
  pause = false
end

stopReactors()
stopNetwork()
