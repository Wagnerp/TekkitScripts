-- Description: Nuclear Power Plant Controller
-- Authors:     andersevenrud, larsmaehlum
-- URL:         https://github.com/andersevenrud/TekkitScripts

-- Configuration
pulseTime         = 0.4
sleepTime         = 0.1
coolantTime       = 5
fuelTime          = 10
checkTicks        = 10
rebootTries       = 3
reactorsEnabled   = {1, 2}
reactorCount      = 2
monitorClientIds  = {45}

-- Thresholds
maxCoolant  = 10
maxFuel     = 44
maxSlots    = 54
maxHeat     = 2000

-- Peripherals
wlanOn        = true
wlanSide      = "top"
bundleSide    = "back"
buttonSide    = "front"
sensorName    = "Sensor"
wireTriggers  = {}

table.insert(wireTriggers, {
  power         = colors.red,
  coolant       = colors.lime,
  fuel          = colors.yellow,
  alarm         = colors.orange
})
table.insert(wireTriggers, {
  power         = colors.blue,
  coolant       = colors.white,
  fuel          = colors.black,
  alarm         = colors.orange
})

-- Internal variables
debugOn      = false                      -- Debug mode, cmd argument
dryRun       = false                      -- Don't send any signals, cmd argument
_argv        = { ... }                    -- Cmd arguments
_ctrl        = sensors.getController()    -- Sensor controller
_tick        = 0                          -- For checking contents
_tick2       = 0                          -- For button delay
_inQueue     = {}                         -- Entities in queue
_overHeated  = {}
_lastStatus  = {}
_rebootTries = {}
_running     = true                       -- Loop running ?
_started     = false                      -- Button clicked once ?
_alarm       = false

for i = 1, reactorCount do
  table.insert(_rebootTries, 0)
  table.insert(_overHeated, false)
  table.insert(_lastStatus, {info = {}, contents = {}, state = false})
  table.insert(_inQueue, {coolantTime = 0, fuelTime = 0})
end

-- 
-- Helper functions
-- 

function inArray(k, o)
  local found = false
  for re = 1, #o do
    if o[re] == k then
      found = true
      break
    end
  end
  return (found)
end

function serialize(o)
  local s = ""

  if type(o) == "number" then
    s = s..o
  elseif type(o) == "string" then
    s = s..string.format("%q", o)
  elseif type(o) == "table" then
    s = s.."{\n"
    for k,v in pairs(o) do
      s = s.."  [" .. serialize(k) .."] = " .. serialize(v) .. ",\n"
    end
    s = s.."}\n"
  else
    error("cannot serialize a " .. type(o))
  end

  return (s)
end

function dprint(msg)
  print(os.time() * 1000, " ", msg)
end

function cprint(msg, y)
  term.setCursorPos(1, y)
  term.clearLine()
  print(msg)
end

function prints()
  term.clear()
  term.setCursorPos(1, 1)
  print("!  C:", tostring(maxCoolant), " F:", tostring(maxFuel), " H:", tostring(maxHeat), " | DRY:", tostring(dryRun))
end

function parseCmd()
  local _l = nil
  for i = 1, #_argv do
    local _v = _argv[i]

    if (i % 2) == 1 then
      _l = _v
    else
      if _l == "-dryRun" then
        if _v == "true" then
          dryRun = true
        else
          dryRun = false
        end
      elseif _l == "-debugOn" then
        if _v == "true" then
          debugOn = true
        else
          debugOn = false
        end
      end
    end
  end
end

function clearScreen()
  term.clear()
  term.setCursorPos(1, 1)
end

function startNetwork()
  if wlanOn then
    rednet.open(wlanSide)
  end
end

function stopNetwork()
  if wlanOn then
    rednet.close(wlanSide)
  end
end

-- 
-- Networking
-- 

function sendMessage(client, message)
  if wlanOn then
    if type(client) == "table" then
      for i = 1, #client do
        rednet.send(tonumber(client[i]), message)
      end
    else
      rednet.send(tonumber(client), message)
    end
  end
end

-- 
-- Reactor functions
-- 

function getReactorInfo(id)
  local p = "Reactor"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  local d = sensors.getSensorReadingAsDict(_ctrl, sensorName, t[id], p)

  if not d then
    return {
      heat = 0,
      size = 0,
      addedToEnergyNet = false,
      lastOutput = 0,
      output = 0
    }
  end

  return (d)
end

function getReactorContents(id)
  local p = "ReactorContent"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  local d = sensors.getSensorReadingAsTable(_ctrl, sensorName, t[id], p)

  local contents = {
    coolant  = 0,
    fuel     = 0,
    depleted = 0
  }

  for i = 1, #d do
    local ii = d[i]
    if string.match(ii, "tile.ice") then
      contents.coolant = contents.coolant + 1
    elseif string.match(ii, "UranEmpty") then
      contents.depleted = contents.depleted + 1
    elseif string.match(ii, "Uran") then
      contents.fuel = contents.fuel + 1
    end
  end

  return (contents)
end

function stopReactors()
  for i = 1, #reactorsEnabled do
    stopReactor(reactorsEnabled[i])
  end
end

function startReactors()
  for i = 1, #reactorsEnabled do
    startReactor(reactorsEnabled[i])
  end
end

function startReactor(id)
  if not checkReactorState(id) then
    dprint("#"..id.." >>> STARTING REACTOR <<<")
    sendPulse(wireTriggers[id].power)
  end
end

function stopReactor(id, heat)
  if checkReactorState(id) then
    if _started then
      if heat then
        dprint("#"..id.." >>> STOPPING REACTOR -- WAY TO HOT! <<<")
      else
        dprint("#"..id.." >>> STOPPING REACTOR <<<")
      end
    end

    sendPulse(wireTriggers[id].power)
  end
end

function checkReactorState(id, info)
  if not info then
    info = getReactorInfo(id)
  end

  if info then
    if info.output > 0 then
      return (true)
    end
  end

  return (false)
end

function _pollReactorCoolant(d, i, id)
  local count = 0
  local wants = 0

  if d.coolant < maxCoolant then
    count = maxCoolant - d.coolant
  end

  return (count)
end

function _pollReactorFuel(d, i, id)
  local count = 0
  local wants = 0

  if d.fuel < maxFuel then
    count = maxFuel - d.fuel
  end

  return (count)
end

function pollReactor(id, runcheck)
  local i = getReactorInfo(id)
  local d = getReactorContents(id)
  local e = checkReactorState(id, i)
  local c = nil
  local r = true

  _lastStatus[id].info      = i
  _lastStatus[id].contents  = d
  _lastStatus[id].state     = e

  -- Skip if not enabled
  if not inArray(id, reactorsEnabled) then
    return (r)
  end

  if not dryRun and runcheck then
    local total = (d.coolant + d.fuel + d.depleted)
    local full = total >= maxSlots
    if e then
      -- Check contents
      if _tick >= checkTicks then
        if not full then
          c = _pollReactorCoolant(d, i, id)
          if c > 0 then
            pushCoolant(id, c)
            r = false
          end

          c = _pollReactorFuel(d, i, id)
          if c > 0 then
            pushFuel(id, c)
            r = false
          end
        end
      end

      -- Check environment
      if i.heat > maxHeat then
        soundAlarm(id)
        stopReactor(id, true)
        r = false
        _overHeated[id] = true
      else
        _overHeated[id] = false
      end

      _rebootTries[id] = 0
    else
      -- Check environment
      if _overHeated[id] == true and (_rebootTries[id] <= rebootTries) then
        startReactor(id)
        r = false

        if checkReactorState(id) then
          _overHeated[id] = false
        else
          _rebootTries[id] = _rebootTries[id] + 1
        end
      end

    end
  end

  return (r)
end

-- 
-- External Systems functions
-- 

function sendPulse(color)
  if not dryRun then
    redstone.setBundledOutput(bundleSide, 0)
    os.sleep(pulseTime)
    redstone.setBundledOutput(bundleSide, color)
    os.sleep(pulseTime)
  end
end

function pushCoolant(id, count)
  if not count then count = 1 end

  if  not (_inQueue[id].coolantTime > os.clock()) then
    for i = 1, count do
      dprint("#"..id.." >>> PUSHING COOLANT "..i.."/"..count.." <<<")
      sendPulse(wireTriggers[id].coolant)
    end
    _inQueue[id].coolantTime = os.clock() + coolantTime

    return (true)
  end

  return (false)
end

function pushFuel(id, count)
  if not count then count = 1 end

  if  not (_inQueue[id].fuelTime > os.clock()) then
    for i = 1, count do
      dprint("#"..id.." >>> PUSHING FUEL "..i.."/"..count.." <<<")
      sendPulse(wireTriggers[id].fuel)
    end
    _inQueue[id].fuelTime = os.clock() + fuelTime

    return (true)
  end

  return (false)
end

function soundAlarm(id)
  --sendPulse(wireTriggers[id].alarm)
end

-- 
-- Main program
-- 

local sx, sy = term.getSize()
local starty = (reactorCount + 3)
local maxy   = (sy - starty)
local pause  = false
local inited = false
local lxpos  = 1
local lypos  = starty

-- 1: Bootup
startNetwork()
clearScreen()
parseCmd()
stopReactors()

-- 2: Main loop
while _running do

  -- 2.1: Handle last status
  if inited then
    sendMessage(monitorClientIds, serialize(_lastStatus))

    for i = 1, reactorCount do
      local d = _lastStatus[i].contents
      local i = _lastStatus[i].info
      local e = _lastStatus[i].state
      local msg = "#"..tostring(i).." C:"..tostring(d.coolant).." F:"..tostring(d.fuel).." D:"..tostring(d.depleted).." | H:"..tostring(i.heat).. " O:"..tostring(i.output).." | ON: "..tostring(e)

      cprint(msg, 1 + i)
    end
  else
    prints()
  end

  cprint("-------------------------------------------------", (reactorCount + 2))
  term.setCursorPos(lxpos, lypos)

  -- 2.2: Perform system operations
  for i = 1, reactorCount do
    pause = pollReactor(i, _started) or pause
  end
  if pause then
    os.sleep(sleepTime)
  end

  -- 2.3: Check input button(s)
  if _tick2 > 0 then
    _tick2 = _tick2 - 1
  else
    if rs.getInput(buttonSide) then
      _tick2 = 11

      if _started then
        _running = false
        dprint(">>> SAFE SHUTDOWN :-) <<<")
        break
      else
        _started = true
        startReactors()
      end
    end
  end

  -- 2.4: Check display and prepare for next tick
  lxpos, lypos = term.getCursorPos()
  if (lypos > maxy) then
    lypos = starty
    prints()
  end

  _tick = _tick + 1
  if _tick > checkTicks then
    _tick = 0
  end

  pause = false
  inited = true
end

-- 3: Shutdown
stopReactors()
stopNetwork()
