-- Description: Nuclear Power Plant Controller
-- Authors:     andersevenrud, larsmaehlum
-- URL:         https://github.com/andersevenrud/TekkitScripts

-- Configuration
pulseTime         = 0.4
sleepTime         = 0.1
coolantTime       = 5
startAlarmTime    = 1.0
fuelTime          = 10
checkTicks        = 10
buttonTicks       = 11
rebootTries       = 3
reactorsEnabled   = {1, 2}
reactorCount      = 2
monitorClientIds  = {45}

-- Thresholds
maxCoolant        = 10
maxFuel           = 44
maxSlots          = 54
maxHeat           = 2000

-- Peripherals
wlanOn            = true
wlanSide          = "bottom"
bundleSide        = "back"
buttonSide        = "front"
alarmSide         = "top"
sensorName        = "Sensor"
wireTriggers      = {}
table.insert(wireTriggers, {
  power         = colors.red,
  coolant       = colors.lime,
  fuel          = colors.yellow
})
table.insert(wireTriggers, {
  power         = colors.blue,
  coolant       = colors.white,
  fuel          = colors.black
})

-- Internal variables
debugOn         = false                      -- Debug mode, cmd argument
dryRun          = false                      -- Don't send any signals, cmd argument
_argv           = { ... }                    -- Cmd arguments
_ctrl           = sensors.getController()    -- Sensor controller
_tick           = 0                          -- For checking contents
_tick2          = 0                          -- For button delay
_reactorStatus  = {}                         -- Reactor statuses, see below
_running        = true                       -- Loop running ?
_started        = false                      -- Button clicked once ?

for i = 1, reactorCount do
  table.insert(_reactorStatus, {
    info          = {},
    contents      = {},
    state         = false,
    overHeated    = false,
    rebootTries   = 0,
    coolantTime   = 0,
    fuelTime      = 0
  })
end

-- 
-- Helper functions
-- 

function inArray(k, o)
  local found = false
  for re = 1, #o do
    if o[re] == k then
      found = true
      break
    end
  end
  return (found)
end

function dprint(msg)
  print(string.format("%d %s", os.time() * 1000, msg))
end

function cprint(msg, y)
  term.setCursorPos(1, y)
  term.clearLine()
  print(msg)
end

function prints()
  term.clear()
  term.setCursorPos(1, 1)
  local msg = string.format("!  C:%02d F:%02d S:%02d | H:%04d O:---- | DRY:%s", maxCoolant, maxFuel, maxSlots, maxHeat, tostring(dryRun))
  print(msg)
end

function parseCmd()
  local _l = nil
  for i = 1, #_argv do
    local _v = _argv[i]

    if (i % 2) == 1 then
      _l = _v
    else
      if _l == "-dryRun" then
        if _v == "true" then
          dryRun = true
        else
          dryRun = false
        end
      elseif _l == "-debugOn" then
        if _v == "true" then
          debugOn = true
        else
          debugOn = false
        end
      end
    end
  end
end

function clearScreen()
  term.clear()
  term.setCursorPos(1, 1)
end

-- 
-- Networking
-- 

function sendMessage(client, message)
  if wlanOn then
    if type(client) == "table" then
      for i = 1, #client do
        rednet.send(tonumber(client[i]), message)
      end
    else
      rednet.send(tonumber(client), message)
    end
  end
end

function startNetwork()
  if wlanOn then
    rednet.open(wlanSide)
  end
end

function stopNetwork()
  if wlanOn then
    rednet.close(wlanSide)
  end
end

-- 
-- Reactor functions
-- 

function getReactorInfo(id)
  local p = "Reactor"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  local d = nil

  if t and t[id] then
    d = sensors.getSensorReadingAsDict(_ctrl, sensorName, t[id], p)
  end

  if type(d) ~= "table" or (type(d.output) == "nil") then
    d = {
      heat              = 0,
      size              = 0,
      addedToEnergyNet  = false,
      lastOutput        = 0,
      output            = 0
    }
  end

  return (d)
end

function getReactorContents(id)
  local contents = {
    coolant  = 0,
    fuel     = 0,
    depleted = 0
  }

  local p = "ReactorContent"
  local t = sensors.getAvailableTargetsforProbe(_ctrl, sensorName, p)
  if type(t) == "table" and t[id] then
    local d = sensors.getSensorReadingAsTable(_ctrl, sensorName, t[id], p)

    for i = 1, #d do
      local ii = d[i]
      if string.match(ii, "tile.ice") then
        contents.coolant = contents.coolant + 1
      elseif string.match(ii, "UranEmpty") then
        contents.depleted = contents.depleted + 1
      elseif string.match(ii, "Uran") then
        contents.fuel = contents.fuel + 1
      end
    end
  end

  return (contents)
end

function stopReactors()
  for i = 1, #reactorsEnabled do
    stopReactor(reactorsEnabled[i])
  end
end

function startReactors()
  for i = 1, #reactorsEnabled do
    startReactor(reactorsEnabled[i])
  end
end

function startReactor(id)
  if not checkReactorState(id) then
    dprint(string.format("STARTING REACTOR #%d", id))
    sendPulse(wireTriggers[id].power)
  end
end

function stopReactor(id, heat)
  if checkReactorState(id) then
    if _started then
      if heat then
        dprint(string.format("OVERHEATING!!! STOPPING REACTOR #%d", id))
      else
        dprint(string.format("STOPPING REACTOR #%d", id))
      end
    end

    sendPulse(wireTriggers[id].power)
  end
end

function checkReactorState(id, info)
  if not info then
    info = getReactorInfo(id)
  end

  if info then
    if info.output > 0 then
      return (true)
    end
  end

  return (false)
end

function _pollReactorCoolant(d, i, id)
  local count = 0
  if d.coolant < maxCoolant then
    count = maxCoolant - d.coolant
  end

  return (count)
end

function _pollReactorFuel(d, i, id)
  local count = 0
  if d.fuel < maxFuel then
    count = maxFuel - d.fuel
  end

  return (count)
end

function pollReactor(id, runcheck)
  local i = getReactorInfo(id)
  local d = getReactorContents(id)
  local e = checkReactorState(id, i)
  local c = nil
  local r = true

  _reactorStatus[id].info      = i
  _reactorStatus[id].contents  = d
  _reactorStatus[id].state     = e

  -- Skip if not enabled
  if not inArray(id, reactorsEnabled) then
    return (r)
  end

  if debugOn then
    dprint("Polling #"..id)
  end

  if not dryRun and runcheck then
    local total = (d.coolant + d.fuel + d.depleted)
    local full = total >= maxSlots
    if e then
      -- Check contents
      if _tick >= checkTicks then
        if not full then
          c = _pollReactorCoolant(d, i, id)
          if c > 0 then
            pushCoolant(id, c)
            r = false
          end

          c = _pollReactorFuel(d, i, id)
          if c > 0 then
            pushFuel(id, c)
            r = false
          end
        end
      end

      -- Check environment
      if i.heat > maxHeat then
        soundAlarm()
        stopReactor(id, true)
        r = false
        _reactorStatus[id].overHeated = true
      else
        stopAlarm()
        _reactorStatus[id].overHeated = false
      end

      _reactorStatus[id].rebootTries = 0
    else
      -- Check environment
      if _reactorStatus[id].overHeated == true and (_reactorStatus[id].rebootTries <= rebootTries) then
        startReactor(id)
        r = false

        if checkReactorState(id) then
          _reactorStatus[id].overHeated = false
          stopAlarm()
        else
          _reactorStatus[id].rebootTries = _reactorStatus[id].rebootTries + 1
        end
      end

    end
  end

  return (r)
end

-- 
-- External Systems functions
-- 

function checkWire(color)
  return 
end

function sendPulse(color, stimeout, etimeout)
  if not stimeout then stimeout = pulseTime end
  if not etimeout then etimeout = pulseTime end

  if not dryRun then
    redstone.setBundledOutput(bundleSide, 0)
    os.sleep(stimeout)
    redstone.setBundledOutput(bundleSide, color)
    os.sleep(etimeout)
  end
end

function pushCoolant(id, count)
  if not count then count = 1 end

  if  not (_reactorStatus[id].coolantTime > os.clock()) then
    for i = 1, count do
      dprint(string.format("PUSHING COOLANT %d/%d TO REACTOR #%d", i, count, id))
      sendPulse(wireTriggers[id].coolant)
    end
    _reactorStatus[id].coolantTime = os.clock() + coolantTime

    return (true)
  end

  return (false)
end

function pushFuel(id, count)
  if not count then count = 1 end

  if  not (_reactorStatus[id].fuelTime > os.clock()) then
    for i = 1, count do
      dprint(string.format("PUSHING FUEL %d/%d TO REACTOR #%d", i, count, id))
      sendPulse(wireTriggers[id].fuel)
    end
    _reactorStatus[id].fuelTime = os.clock() + fuelTime

    return (true)
  end

  return (false)
end

function soundAlarm(timeout)
  rs.setOutput(alarmSide, true)
  if timeout then
    os.sleep(timeout)
    stopAlarm()
  end
end

function stopAlarm()
  rs.setOutput(alarmSide, false)
end

-- 
-- Main program
-- 

local sx, sy = term.getSize()
local starty = (reactorCount + 3)
local pause  = false
local inited = false
local lxpos  = 1
local lypos  = starty

-- 1: Bootup
startNetwork()
clearScreen()
parseCmd()
stopReactors()
stopAlarm()

-- 2: Main loop
while _running do

  -- 2.1: Handle last status
  if inited then
    sendMessage(monitorClientIds, textutils.serialize(_reactorStatus))

    for c = 1, reactorCount do
      local d = _reactorStatus[c].contents
      local i = _reactorStatus[c].info
      local e = _reactorStatus[c].state
      local msg = string.format("#%d C:%02d F:%02d D:%02d | H:%04d O:%04d | ON:%s", c, d.coolant, d.fuel, d.depleted, i.heat, i.output, tostring(e))
      cprint(msg, 1 + c)
    end
  else
    prints()
  end

  cprint("-------------------------------------------------", (reactorCount + 2))
  term.setCursorPos(lxpos, lypos)

  -- 2.2: Perform system operations
  for i = 1, #reactorsEnabled do
    pause = pollReactor(reactorsEnabled[i], _started) or pause
  end
  if pause then
    os.sleep(sleepTime)
  end

  -- 2.3: Check input button(s)
  if _tick2 > 0 then
    _tick2 = _tick2 - 1
  else
    if rs.getInput(buttonSide) then
      _tick2 = buttonTicks

      if _started then
        _running = false
        dprint(">>> SAFE SHUTDOWN :-) <<<")
        break
      else
        soundAlarm(startAlarmTime)
        _started = true
        startReactors()
      end
    end
  end

  -- 2.4: Check display and prepare for next tick
  lxpos, lypos = term.getCursorPos()
  if (lypos > (sy - 1)) then
    lypos = starty
    prints()
  end

  _tick = _tick + 1
  if _tick > checkTicks then
    _tick = 0
  end

  pause = false
  inited = true
end

-- 3: Shutdown
stopReactors()
stopNetwork()
stopAlarm()
